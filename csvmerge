#!/usr/bin/python3
"""Merge rows of CSV file with the special feature of joining multiple columns that cannot be done in your spreadsheet application."""
"""
Author:
    Fikrul
"""
import sys
import csv
import argparse
import re
import itertools
from collections import OrderedDict


def main():
  args = parse_args()
  p = Processor(args)
  if args.filename:
    with open(args.filename) as csvfile:
      p.process_file(csvfile)
  else:
    p.process_file(sys.stdin)


def parse_args():
  parser = argparse.ArgumentParser(description=__doc__)
  parser.add_argument('filename', metavar='FILE', nargs='?',
    help='input filename (default to STDIN)')
  parser.add_argument('-m', '--merge', metavar='COLS', action='append',
    default=[], type=split_ints, dest='merge_indices',
    help='indices of columns (each level separated by commas) that should be merged when others are same, this option can be specified more than once')
  parser.add_argument('-d', '--merge-dest', metavar='FINAL_COL', 
    action='append', type=int, dest='merge_result_indices',
    help='index where result of merging specified by corresponding -m option should be inserted into the resulting columns, if specified, this argument should occur as many as argument -m (default to "-d 0 -d 1 -d 3 ...")')
  parser.add_argument('-l', '--left-paren', default=' (',
    help='left parenthesis used for merging (default to " (")')
  parser.add_argument('-r', '--right-paren', default=')',
    help='right parenthesis used for merging (default to ")")')
  parser.add_argument('-c', '--comma', default=', ',
    help='comma used for merging (default to ", ")')
  args = parser.parse_args()
  if args.merge_result_indices is not None and \
      len(args.merge_indices) != len(args.merge_result_indices):
    parser.error('the number of argument -m/--merge ({}) didn\'t equal to the number of argument -d/--merge-dest ({})'.format(
      len(args.merge_indices), len(args.merge_result_indices)))
  return args


def split_ints(s):
  return [int(i) for i in s.split(',')]


class Processor(object):

  def __init__(self, options):
    for k in ('merge_indices', 'merge_result_indices', 'left_paren',
        'right_paren', 'comma'):
      setattr(self, k, getattr(options, k))

  def process_file(self, f):
    self.input_file = f
    self.process()

  def process(self):
    merge_indices = self.merge_indices
    all_merge_indices = set(itertools.chain(*merge_indices))
    reader = csv.reader(self.input_file)
    result = OrderedDict() # dict of unique rows (other cols => [merged col])
    for row in reader:
      k = tuple(col for i,col in enumerate(row) if i 
        not in all_merge_indices)
      merged_cols = result.get(k)
      if not merged_cols: # create blank cols
        merged_cols = tuple({} for _ in range(len(merge_indices)))
        result[k] = merged_cols
      for col,indices in zip(merged_cols, merge_indices): # insert
        self.put_recursively(col, row, indices)

    self.print(result)

  def join_merged_column(self, key, d):
    if d is not None:
      children = self.comma.join(self.join_merged_column(k, v) for k,v in 
        sorted(d.items(), key=lambda x: natural_sort_key(x[0])))
      if key is None: return children
      else: return key + self.left_paren + children + self.right_paren
    else: # the leaf
      return key if key is not None else ''

  @staticmethod
  def put_recursively(dst, row, indices):
    d = dst
    for i in indices[:-1]:
      col = row[i]
      v = d.get(col)
      if v is None:
        v = {}
        d[col] = v
      d = v
    col = row[indices[-1]]
    d[col] = None

  def print(self, result):
    merged_indices = self.merge_result_indices or \
      [0] * len(self.merge_indices)
    writer = csv.writer(sys.stdout)
    for others,mergeds in result.items():
      row = list(others)
      for merged,index in zip(mergeds, merged_indices):
        m = self.join_merged_column(None, merged)
        row.insert(index, m)
      writer.writerow(row)


def natural_sort_key(s):
  if len(s) <= 32:
    return [int(i) if i.isnumeric() else i for i in re.split(_p_num_split, s)]
  else:
    return [s]
_p_num_split = re.compile('([0-9]+)')


if __name__ == '__main__':
  main()

# fikr4n 2015
