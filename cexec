#!/usr/bin/python3
"""Execute commands concurrently, limited to some numbers at a time while others are enqueued, a.k.a. process pool"""
# Author: fikr4n

import argparse
import sys
import subprocess
import threading
from multiprocessing.dummy import Pool


class Object: pass

_status = Object()
_args = Object()
_lock = threading.Lock()
_screen_width = int(subprocess.check_output(['tput', 'cols']))


def main():
  p = argparse.ArgumentParser(description=__doc__)
  p.add_argument('-p', '--params', nargs='+',
    help='parameters to be substituted with "{}" in --command')
  p.add_argument('-n', '--pool-size', metavar='NUM', type=int, default=5,
    help='number of process pool (default to 5)')
  p.add_argument('-s', '--shell', default='/bin/bash',
    help='shell to be used (default to /bin/bash)')
  p.add_argument('-P', '--no-show-progress', action='store_true',
    help='do not show progress info')
  p.add_argument('-w', '--show-command', action='store_true',
    help='show command before execution')
  p.add_argument('-c', '--command', nargs=argparse.REMAINDER,
    help='if supplied, it will be executed once for each --params value; otherwise commands will be read from STDIN (each line is a command) and --params is ignored')
  args = p.parse_args()

  if not args.command:  # read stdin
    args.commands = [i for i in sys.stdin if i]
  else:  # let's build
    command = ' '.join(args.command)
    args.commands = [command.format(i) for i in args.params]
  pool = Pool(args.pool_size)
  _status.waiting = len(args.commands)
  _status.finished = 0

  _args.__dict__.update(args.__dict__)
  try:
    pool.map(execute, args.commands)
  except KeyboardInterrupt:
    pass
  
  if not args.no_show_progress:
    print()


def execute(command):
  update_status(-1, 0)
  if _args.show_command:
    print('[*] Executing "{}"...'.format(command.strip()))
  r = subprocess.call(command, shell=True, executable=_args.shell)
  update_status(0, 1)
  return r


def update_status(cwaiting, cfinished):
  with _lock:
    _status.waiting += cwaiting
    _status.finished += cfinished
    if not _args.no_show_progress:
      s = '[*] waiting: {}, running: {}, finished: {}'.format(_status.waiting,
        len(_args.commands) - _status.waiting - _status.finished,
        _status.finished)
      print('\r' + s + ' ' * (_screen_width - len(s)), end='')

if __name__ == '__main__':
  main()

# fikr4n 2015
